window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "IGEnvironments", "modulename": "IGEnvironments", "type": "module", "doc": "<p></p>\n"}, {"fullname": "IGEnvironments.InformationGatheringEnv", "modulename": "IGEnvironments", "qualname": "InformationGatheringEnv", "type": "class", "doc": "<p>An environment that hosts multiple independent agents.</p>\n\n<p>Agents are identified by (string) agent ids. Note that these \"agents\" here\nare not to be confused with RLlib Trainers, which are also sometimes\nreferred to as \"agents\" or \"RL agents\".</p>\n", "bases": "ray.rllib.env.multi_agent_env.MultiAgentEnv"}, {"fullname": "IGEnvironments.InformationGatheringEnv.__init__", "modulename": "IGEnvironments", "qualname": "InformationGatheringEnv.__init__", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">env_config</span><span class=\"p\">:</span> <span class=\"nb\">dict</span></span>)</span>"}, {"fullname": "IGEnvironments.InformationGatheringEnv.reset", "modulename": "IGEnvironments", "qualname": "InformationGatheringEnv.reset", "type": "function", "doc": "<p>Reset all the variables and the fleet. This method must be called before the first step of the episode.\nIt resets the fleet position, the measurements, the ground truth, the surrogate model and the uncertainty.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n<pre><code>    The initial observation of the environment in a dictionary of agents.\n</code></pre>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "IGEnvironments.InformationGatheringEnv.eval", "modulename": "IGEnvironments", "qualname": "InformationGatheringEnv.eval", "type": "function", "doc": "<p>Change the environment to evaluation mode. In this mode,\ncomputationally expensive operations are enabled for evaluation.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "IGEnvironments.InformationGatheringEnv.update_model", "modulename": "IGEnvironments", "qualname": "InformationGatheringEnv.update_model", "type": "function", "doc": "<p>Fit the gaussian process using the new_measurements and return a new inferred map and its uncertainty.\nThe process will update the gaussian model sequentially for each agent in <em>agents_ids</em>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>new_measurements</strong>:  The new measurements to fit the model with in a dictionary.</li>\n<li><strong>agents_ids</strong>:  The ids of those agents that generated the measurements. If None, all the agents will be updated.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n<pre><code>    - mu - The new inferred map mu.\n    - sigma - The new inferred uncertainty sigma.\n</code></pre>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">new_measurements</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>,</span><span class=\"param\">\t<span class=\"n\">agents_ids</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> (&lt;class &#x27;numpy.ndarray&#x27;&gt;, &lt;class &#x27;numpy.ndarray&#x27;&gt;):</span></span>", "funcdef": "def"}, {"fullname": "IGEnvironments.InformationGatheringEnv.reward_function", "modulename": "IGEnvironments", "qualname": "InformationGatheringEnv.reward_function", "type": "function", "doc": "<p>The reward function is defined depending on the reward_type parameter\n1) 'uncertainty': the reward is merely the uncertainty decrement of each agent. This will serve for complete coverage\n2) 'regret': the reward is the decrement of uncertainty but weighted with the sampling value of each agent. This will serve for finding maxima\n3) 'error': the reward is the error between the ground truth and the inferred map. This is for characterization.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>collision_array</strong>:  The collision array of the current state.</li>\n<li><strong>agents_ids</strong>:  The ids of those agents that are expecting the reward.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n<pre><code>    - reward: The reward for each agent in a dictionary.\n</code></pre>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">collision_array</span><span class=\"p\">:</span> <span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"n\">agents_ids</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "IGEnvironments.InformationGatheringEnv.process_states", "modulename": "IGEnvironments", "qualname": "InformationGatheringEnv.process_states", "type": "function", "doc": "<p>Render the states of the agents.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>agent_ids</strong>:  The ids of those agents that are expecting the state.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n<pre><code>    - states: The state of the agents in a dictionary.\n</code></pre>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">agent_ids</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "IGEnvironments.InformationGatheringEnv.individual_state", "modulename": "IGEnvironments", "qualname": "InformationGatheringEnv.individual_state", "type": "function", "doc": "<p>Return the state of an individual agent.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>agent_indx</strong>:  The index of the agent.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n<pre><code>    - state: The state of the agent. Could be a matrix (visual) or a dictionary (hybrid).\n</code></pre>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">agent_indx</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "IGEnvironments.InformationGatheringEnv.update_vehicles_ground_truths", "modulename": "IGEnvironments", "qualname": "InformationGatheringEnv.update_vehicles_ground_truths", "type": "function", "doc": "<p>Setter to update the ground truth of the vehicles.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "IGEnvironments.InformationGatheringEnv.action_dict_to_targets", "modulename": "IGEnvironments", "qualname": "InformationGatheringEnv.action_dict_to_targets", "type": "function", "doc": "<p>Transform the actions of the dictionary to a dictionary with the target goals.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>a_dict</strong>:  The dictionary of actions. Every key is an agent_id, and the values corresponds to the action.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n<pre><code>    - targets: An array that contains the target positions for every vehicle.\n</code></pre>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">a_dict</span><span class=\"p\">:</span> <span class=\"nb\">dict</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "IGEnvironments.InformationGatheringEnv.linear_min_max", "modulename": "IGEnvironments", "qualname": "InformationGatheringEnv.linear_min_max", "type": "function", "doc": "<p>Transform the input x into a line</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">y_min</span>, </span><span class=\"param\"><span class=\"n\">y_max</span>, </span><span class=\"param\"><span class=\"n\">x_min</span>, </span><span class=\"param\"><span class=\"n\">x_max</span>, </span><span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "IGEnvironments.InformationGatheringEnv.step", "modulename": "IGEnvironments", "qualname": "InformationGatheringEnv.step", "type": "function", "doc": "<p>Process the actions. The action is processed for those waiting vehicles. The fleet is updated until one/all vehicles are ready.\nEvery vehicle takes a measurement and the reward is processed</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>action_dict</strong>:  The dictionary of actions. Every key is an agent_id, and the values corresponds to the action.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n<pre><code>    - reward: The reward for each agent.\n    - observation: The observation for each agent.\n    - done: A boolean that indicates if the episode is finished.\n    - info: A dictionary that contains additional information.\n</code></pre>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">action_dict</span><span class=\"p\">:</span> <span class=\"nb\">dict</span></span><span class=\"return-annotation\">) -> (&lt;class &#x27;dict&#x27;&gt;, &lt;class &#x27;dict&#x27;&gt;, &lt;class &#x27;dict&#x27;&gt;, &lt;class &#x27;dict&#x27;&gt;):</span></span>", "funcdef": "def"}, {"fullname": "IGEnvironments.InformationGatheringEnv.render", "modulename": "IGEnvironments", "qualname": "InformationGatheringEnv.render", "type": "function", "doc": "<p>Render the environment.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;human&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "IGEnvironments.InformationGatheringEnv.get_action_mask", "modulename": "IGEnvironments", "qualname": "InformationGatheringEnv.get_action_mask", "type": "function", "doc": "<p>Get the invalid action mask for a certain vehicle (<em>ind</em>)</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>ind</strong>:  The index of the vehicle</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n<pre><code>    - mask: The invalid action mask for the vehicle, where true means that the action is valid.\n</code></pre>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ind</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "Vehicle", "modulename": "Vehicle", "type": "module", "doc": "<p></p>\n"}, {"fullname": "Vehicle.FleetState", "modulename": "Vehicle", "qualname": "FleetState", "type": "class", "doc": "<p>Fleet state enumeration.\nIt is used to define the state of the fleet.\nIt can be:\n        - ON_WAY: The vehicle is on the way to the target position.\n        - WAITING_FOR_ACTION: The vehicle is waiting for an action.\n        - COLLIDED: The vehicle has collided with another vehicle or the environment boundary.\n        - FINISHED: The vehicle has reached its maximum distance and no longer move.\n        - LAST_ACTION: The vehicle has finished with the last action.</p>\n", "bases": "enum.Enum"}, {"fullname": "Vehicle.FleetState.WAITING_FOR_ACTION", "modulename": "Vehicle", "qualname": "FleetState.WAITING_FOR_ACTION", "type": "variable", "doc": "<p></p>\n", "default_value": " = &lt;FleetState.WAITING_FOR_ACTION: 0&gt;"}, {"fullname": "Vehicle.FleetState.COLLIDED", "modulename": "Vehicle", "qualname": "FleetState.COLLIDED", "type": "variable", "doc": "<p></p>\n", "default_value": " = &lt;FleetState.COLLIDED: 1&gt;"}, {"fullname": "Vehicle.FleetState.ON_WAY", "modulename": "Vehicle", "qualname": "FleetState.ON_WAY", "type": "variable", "doc": "<p></p>\n", "default_value": " = &lt;FleetState.ON_WAY: 2&gt;"}, {"fullname": "Vehicle.FleetState.GOAL_REACHED", "modulename": "Vehicle", "qualname": "FleetState.GOAL_REACHED", "type": "variable", "doc": "<p></p>\n", "default_value": " = &lt;FleetState.GOAL_REACHED: 3&gt;"}, {"fullname": "Vehicle.FleetState.LAST_ACTION", "modulename": "Vehicle", "qualname": "FleetState.LAST_ACTION", "type": "variable", "doc": "<p></p>\n", "default_value": " = &lt;FleetState.LAST_ACTION: 4&gt;"}, {"fullname": "Vehicle.FleetState.FINISHED", "modulename": "Vehicle", "qualname": "FleetState.FINISHED", "type": "variable", "doc": "<p></p>\n", "default_value": " = &lt;FleetState.FINISHED: 5&gt;"}, {"fullname": "Vehicle.Vehicle", "modulename": "Vehicle", "qualname": "Vehicle", "type": "class", "doc": "<p></p>\n"}, {"fullname": "Vehicle.Vehicle.__init__", "modulename": "Vehicle", "qualname": "Vehicle.__init__", "type": "function", "doc": "<p>This class defines a vehicle in a 2D plane. The vehicle can move and take samples according to a\nGround Truth. The vehicle receives a new position and tries to reach it. If it is not possible,\na flag is raises.  Once the movement is completed, a sample is taken.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">vehicle_id</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">initial_position</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">vehicle_configuration</span><span class=\"p\">:</span> <span class=\"nb\">dict</span></span>)</span>"}, {"fullname": "Vehicle.Vehicle.reset_vehicle", "modulename": "Vehicle", "qualname": "Vehicle.reset_vehicle", "type": "function", "doc": "<p>Reset the vehicle position and return the first sample.</p>\n\n<p>Returns:\n       measurement (dict): The first sample of the vehicle.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "Vehicle.Vehicle.move_to", "modulename": "Vehicle", "qualname": "Vehicle.move_to", "type": "function", "doc": "<p>This function directly moves the vehicle to a new position. If the movement is possible, the function returns\nTrue. If the movement is not possible, the function returns False. The funtion also returns a sample value</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">attemped_position</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> [&lt;class &#x27;bool&#x27;&gt;, &lt;class &#x27;numpy.ndarray&#x27;&gt;]:</span></span>", "funcdef": "def"}, {"fullname": "Vehicle.Vehicle.set_target", "modulename": "Vehicle", "qualname": "Vehicle.set_target", "type": "function", "doc": "<p>Set the target position. Put the vehicle state to ON_WAY.</p>\n\n<p>Args:\n        target_position (np.ndarray): The target position.\nReturns:\n        vehicle_state (FleetState): The vehicle state which will be ON_WAY, of course.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">target_position</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Vehicle</span><span class=\"o\">.</span><span class=\"n\">FleetState</span>:</span></span>", "funcdef": "def"}, {"fullname": "Vehicle.Vehicle.step", "modulename": "Vehicle", "qualname": "Vehicle.step", "type": "function", "doc": "<p>Process one discrete step of the vehicle and process the step according to the result of this movement.</p>\n\n<p>Returns:</p>\n\n<pre><code>    state (FleetState): The state of the vehicle.\n    measurement (dict): The sample of the vehicle.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> [&lt;enum &#x27;FleetState&#x27;&gt;, &lt;class &#x27;numpy.ndarray&#x27;&gt;]:</span></span>", "funcdef": "def"}, {"fullname": "Vehicle.Vehicle.step_with_direction", "modulename": "Vehicle", "qualname": "Vehicle.step_with_direction", "type": "function", "doc": "<p>This function moves the vehicle in a direction. If the movement is possible, the function returns\nTrue. If the movement is not possible, the function returns False.</p>\n\n<p>Args:\n        direction (np.ndarray): The direction of the movement.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">direction</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "Vehicle.Vehicle.is_the_position_valid", "modulename": "Vehicle", "qualname": "Vehicle.is_the_position_valid", "type": "function", "doc": "<p>This function checks if the position is valid.</p>\n\n<p>Args:\n       position (np.ndarray): The position to check.</p>\n\n<p>Returns:\n       valid (bool): True if the position is valid.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">position</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "Vehicle.Vehicle.take_measurement", "modulename": "Vehicle", "qualname": "Vehicle.take_measurement", "type": "function", "doc": "<p>This function takes a measurement of the vehicle. It takes a rectangular sample of\nthe ground truth map and returns a dictionary with the measurements.</p>\n\n<p>Returns:\n        measurement (dict): The measurement of the vehicle.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "Fleet", "modulename": "Fleet", "type": "module", "doc": "<p></p>\n"}, {"fullname": "Fleet.Fleet", "modulename": "Fleet", "qualname": "Fleet", "type": "class", "doc": "<p></p>\n"}, {"fullname": "Fleet.Fleet.__init__", "modulename": "Fleet", "qualname": "Fleet.__init__", "type": "function", "doc": "<p>A fleet coordinator object that is responsible for the coordination of the vehicles in the fleet.\nIt is in charge of dispatching the reset conditions, process the movements and the measurements of every agent.</p>\n\n<p>Args:\n        fleet_configuration (dict): A dictionary containing the configuration of the fleet.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fleet_configuration</span><span class=\"p\">:</span> <span class=\"nb\">dict</span></span>)</span>"}, {"fullname": "Fleet.Fleet.reset", "modulename": "Fleet", "qualname": "Fleet.reset", "type": "function", "doc": "<p>Reset the fleet position and measurements.</p>\n\n<p>Returns:\n       fleet_state: List of states of the fleet</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "Fleet.Fleet.set_target_position", "modulename": "Fleet", "qualname": "Fleet.set_target_position", "type": "function", "doc": "<p>Set a new position target for an agent if it is not finished</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">agent_id</span>, </span><span class=\"param\"><span class=\"n\">target_position</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "Fleet.Fleet.step", "modulename": "Fleet", "qualname": "Fleet.step", "type": "function", "doc": "<p>Compute one discrete step for every vehicle and retreive the measurements and new states if they are available.\nNote that when the vehicle has finished the mission or is moving, the measurement is None.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> (&lt;class &#x27;list&#x27;&gt;, &lt;class &#x27;list&#x27;&gt;):</span></span>", "funcdef": "def"}, {"fullname": "Fleet.Fleet.update_syncronously", "modulename": "Fleet", "qualname": "Fleet.update_syncronously", "type": "function", "doc": "<p>Update the state of the fleet until all vehicles are not in ON_WAY state</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> (&lt;class &#x27;list&#x27;&gt;, &lt;class &#x27;list&#x27;&gt;):</span></span>", "funcdef": "def"}, {"fullname": "Fleet.Fleet.update_asyncronously", "modulename": "Fleet", "qualname": "Fleet.update_asyncronously", "type": "function", "doc": "<p>Update the state of the fleet until at least one vehicle is not in ON_WAY state</p>\n\n<p>Returns:\n        fleet_state: List of states of the fleet\n        measurements: List of measurements of the fleet</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "Fleet.Fleet.get_positions", "modulename": "Fleet", "qualname": "Fleet.get_positions", "type": "function", "doc": "<p>Method to obtain the positions of the vehicles in the fleet.</p>\n\n<p>Returns:\n        positions: numpy array of positions of the vehicles in the fleet.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "Fleet.Fleet.set_state", "modulename": "Fleet", "qualname": "Fleet.set_state", "type": "function", "doc": "<p>Setter of a state of given agent</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">agent_id</span>, </span><span class=\"param\"><span class=\"n\">veh_state</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ShekelGroundTruth", "modulename": "ShekelGroundTruth", "type": "module", "doc": "<p></p>\n"}, {"fullname": "ShekelGroundTruth.Shekel", "modulename": "ShekelGroundTruth", "qualname": "Shekel", "type": "class", "doc": "<p>Ground Truth generator class.\nIt creates a ground truth within the specified navigation map.\nThe ground truth is generated randomly following some realistic rules of the enviornment\nand using a Shekel function.</p>\n"}, {"fullname": "ShekelGroundTruth.Shekel.__init__", "modulename": "ShekelGroundTruth", "qualname": "Shekel.__init__", "type": "function", "doc": "<p>Maximum number of peaks encountered in the scenario.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">grid</span>, </span><span class=\"param\"><span class=\"n\">resolution</span>, </span><span class=\"param\"><span class=\"n\">max_number_of_peaks</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">is_bounded</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"mi\">0</span></span>)</span>"}, {"fullname": "ShekelGroundTruth.Shekel.C", "modulename": "ShekelGroundTruth", "qualname": "Shekel.C", "type": "variable", "doc": "<p>Creation of the map field</p>\n"}, {"fullname": "ShekelGroundTruth.Shekel.shekel_arg0", "modulename": "ShekelGroundTruth", "qualname": "Shekel.shekel_arg0", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">sol</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ShekelGroundTruth.Shekel.create_field", "modulename": "ShekelGroundTruth", "qualname": "Shekel.create_field", "type": "function", "doc": "<p>Creation of the normalized z field</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ShekelGroundTruth.Shekel.reset", "modulename": "ShekelGroundTruth", "qualname": "Shekel.reset", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">random_benchmark</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ShekelGroundTruth.Shekel.read", "modulename": "ShekelGroundTruth", "qualname": "Shekel.read", "type": "function", "doc": "<p>Read the complete ground truth or a certain position</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">position</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ShekelGroundTruth.Shekel.render", "modulename": "ShekelGroundTruth", "qualname": "Shekel.render", "type": "function", "doc": "<p>Show the ground truth</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "ShekelGroundTruth.Shekel.step", "modulename": "ShekelGroundTruth", "qualname": "Shekel.step", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "OilSpillEnvironment", "modulename": "OilSpillEnvironment", "type": "module", "doc": "<p></p>\n"}, {"fullname": "OilSpillEnvironment.OilSpillEnv", "modulename": "OilSpillEnvironment", "qualname": "OilSpillEnv", "type": "class", "doc": "<p></p>\n"}, {"fullname": "OilSpillEnvironment.OilSpillEnv.__init__", "modulename": "OilSpillEnvironment", "qualname": "OilSpillEnv.__init__", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">boundaries_map</span>, </span><span class=\"param\"><span class=\"n\">dt</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">kw</span><span class=\"o\">=</span><span class=\"mf\">0.5</span>, </span><span class=\"param\"><span class=\"n\">kc</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">gamma</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">flow</span><span class=\"o\">=</span><span class=\"mi\">50</span>, </span><span class=\"param\"><span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"mi\">0</span></span>)</span>"}, {"fullname": "OilSpillEnvironment.OilSpillEnv.reset", "modulename": "OilSpillEnvironment", "qualname": "OilSpillEnv.reset", "type": "function", "doc": "<p>Reset the env variables</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">random_benchmark</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "OilSpillEnvironment.OilSpillEnv.step", "modulename": "OilSpillEnvironment", "qualname": "OilSpillEnv.step", "type": "function", "doc": "<p>Process the action and update the environment state</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "OilSpillEnvironment.OilSpillEnv.get_current_speed", "modulename": "OilSpillEnvironment", "qualname": "OilSpillEnv.get_current_speed", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">position</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "OilSpillEnvironment.OilSpillEnv.render", "modulename": "OilSpillEnvironment", "qualname": "OilSpillEnv.render", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "OilSpillEnvironment.OilSpillEnv.update_to_time", "modulename": "OilSpillEnvironment", "qualname": "OilSpillEnv.update_to_time", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">t</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();